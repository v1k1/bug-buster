
> ts-parser@1.0.0 run
> ts-node ./src/parser.ts C:\Users\vikassingh\work\ms\azure-sdk-for-js\sdk\cosmosdb\cosmos\test\public\functional\client.spec.ts

the file is C:\Users\vikassingh\work\ms\azure-sdk-for-js\sdk\cosmosdb\cosmos\test\public\functional\client.spec.ts
node: 308
node: 269
node: 270
node: 79
node: 10
<ref *2> TokenObject {
  pos: 93,
  end: 102,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 0,
    end: 103,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [Circular *1],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 81,
      end: 88,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: [IdentifierObject],
      namedBindings: undefined
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: 'assert',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 125,
  end: 133,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 103,
    end: 134,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 110,
      end: 120,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: 'mocha',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 156,
  end: 163,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 134,
    end: 164,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 141,
      end: 151,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: 'http',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 193,
  end: 208,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 164,
    end: 209,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 171,
      end: 188,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: '../../../src',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 234,
  end: 258,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 209,
    end: 259,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 216,
      end: 229,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: '../common/_testConfig',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 285,
  end: 314,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 259,
    end: 315,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 266,
      end: 280,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: '../common/_fakeTestSecrets',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 273
node: 79
node: 273
node: 79
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 410,
  end: 434,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 315,
    end: 435,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 322,
      end: 405,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: '../common/TestHelpers',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 467,
  end: 491,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 435,
    end: 492,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 442,
      end: 462,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: 'node-abort-controller',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 535,
  end: 553,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 492,
    end: 554,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 499,
      end: 530,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: '@azure/identity',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 269
node: 270
node: 272
node: 273
node: 79
node: 10
<ref *2> TokenObject {
  pos: 594,
  end: 619,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 554,
    end: 620,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: SourceFileObject {
      pos: 0,
      end: 6545,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: undefined,
      kind: 308,
      statements: [Array],
      endOfFileToken: [TokenObject],
      fileName: 'C:/Users/vikassingh/work/ms/azure-sdk-for-js/sdk/cosmosdb/cosmos/test/public/functional/client.spec.ts',
      text: '// Copyright (c) Microsoft Corporation.\n' +
        '// Licensed under the MIT license.\n' +
        'import assert from "assert";\n' +
        'import { Suite } from "mocha";\n' +
        'import { Agent } from "http";\n' +
        'import { CosmosClient } from "../../../src";\n' +
        'import { endpoint } from "../common/_testConfig";\n' +
        'import { masterKey } from "../common/_fakeTestSecrets";\n' +
        'import {\n' +
        '  getTestDatabase,\n' +
        '  getTestContainer,\n' +
        '  generateDocuments,\n' +
        '  bulkInsertItems,\n' +
        '} from "../common/TestHelpers";\n' +
        'import { AbortController } from "node-abort-controller";\n' +
        'import { UsernamePasswordCredential } from "@azure/identity";\n' +
        'import { defaultConnectionPolicy } from "../../../src/documents";\n' +
        '\n' +
        'describe("Client Tests", function (this: Suite) {\n' +
        '  this.timeout(process.env.MOCHA_TIMEOUT || 20000);\n' +
        '\n' +
        '  describe("Validate client request timeout", function () {\n' +
        '    it("timeout occurs within expected timeframe", async function () {\n' +
        '      // making timeout 1 ms to make sure it will throw\n' +
        '      // (create database request takes 10ms-15ms to finish on emulator)\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        '      // create database\n' +
        '      try {\n' +
        '        await getTestDatabase("request timeout", client);\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "TimeoutError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '\n' +
        '  describe("Constructor", function () {\n' +
        '    it("Accepts node Agent", function () {\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint: "https://faaaaaake.com",\n' +
        '        agent: new Agent(),\n' +
        '        connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '      });\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '    });\n' +
        '    it("Accepts a connection string", function () {\n' +
        '      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);\n' +
        `      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");\n` +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("throws on a bad connection string", function () {\n' +
        '      assert.throws(() => new CosmosClient(`bad;Connection=string;`));\n' +
        '    });\n' +
        '    it("throws on a bad endpoint", function () {\n' +
        '      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));\n' +
        '    });\n' +
        '    it("fails to read databases with bad AAD authentication", async function () {\n' +
        '      try {\n' +
        '        const credentials = new UsernamePasswordCredential(\n' +
        '          "fake-tenant-id",\n' +
        '          "fake-client-id",\n' +
        '          "fakeUsername",\n' +
        '          "fakePassword"\n' +
        '        );\n' +
        '        const client = new CosmosClient({\n' +
        '          endpoint,\n' +
        '          aadCredentials: credentials,\n' +
        '          connectionPolicy: { enableBackgroundEndpointRefreshing: false },\n' +
        '        });\n' +
        '        await client.databases.readAll().fetchAll();\n' +
        '      } catch (e: any) {\n' +
        '        assert.equal(e.name, "CredentialUnavailableError");\n' +
        '      }\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Validate user passed AbortController.signal", function () {\n' +
        '    it("should throw exception if aborted during the request", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 1);\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        console.log(err);\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should throw exception if passed an already aborted signal", async function () {\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        controller.abort();\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '        assert.fail("Must throw when trying to connect to database");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '    it("should abort a query", async function () {\n' +
        '      const container = await getTestContainer("abort query");\n' +
        '      await bulkInsertItems(container, generateDocuments(20));\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        setTimeout(() => controller.abort(), 50);\n' +
        '        // Setting maxItemCount = 1 to ensure this query take a long time\n' +
        '        await container.items\n' +
        '          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })\n' +
        '          .fetchAll();\n' +
        '        assert.fail("Must throw");\n' +
        '      } catch (err: any) {\n' +
        '        assert.equal(err.name, "AbortError", "client should throw exception");\n' +
        '      }\n' +
        '    });\n' +
        '    it("should not abort if abort signal is never called", async function () {\n' +
        '      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510\n' +
        '      const client = new CosmosClient({ endpoint, key: masterKey });\n' +
        '      try {\n' +
        '        const controller = new AbortController();\n' +
        '        const signal = controller.signal;\n' +
        '        await client.getDatabaseAccount({ abortSignal: signal });\n' +
        '      } catch (err: any) {\n' +
        '        assert.fail(err);\n' +
        '      }\n' +
        '      client.dispose();\n' +
        '    });\n' +
        '  });\n' +
        '  describe("Background refresher", async function () {\n' +
        '    // not async to leverage done() callback inside setTimeout\n' +
        '    it("should fetch new endpoints", function (done) {\n' +
        '      // set refresh rate to 700ms\n' +
        '      const client = new CosmosClient({\n' +
        '        endpoint,\n' +
        '        key: masterKey,\n' +
        '        connectionPolicy: {\n' +
        '          ...defaultConnectionPolicy,\n' +
        '          endpointRefreshRateInMs: 700,\n' +
        '          enableBackgroundEndpointRefreshing: true,\n' +
        '        },\n' +
        '      });\n' +
        '\n' +
        '      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them\n' +
        '      client\n' +
        '        .getReadEndpoints()\n' +
        '        .then((firstEndpoints) => {\n' +
        '          assert.equal(firstEndpoints.length, 0);\n' +
        '          setTimeout(() => {\n' +
        '            client\n' +
        '              .getReadEndpoints()\n' +
        '              .then((endpoints) => {\n' +
        '                assert.notEqual(firstEndpoints, endpoints);\n' +
        '                done();\n' +
        '                return;\n' +
        '              })\n' +
        '              .catch(console.warn);\n' +
        '          }, 1200);\n' +
        '          return;\n' +
        '        })\n' +
        '        .catch(console.warn);\n' +
        '    });\n' +
        '  });\n' +
        '});\n',
      languageVersion: 2,
      languageVariant: 0,
      scriptKind: 3,
      isDeclarationFile: false,
      hasNoDefaultLib: false,
      bindDiagnostics: [],
      bindSuggestionDiagnostics: undefined,
      externalModuleIndicator: [NodeObject],
      setExternalModuleIndicator: [Function: setExternalModuleIndicator],
      pragmas: Map(0) {},
      checkJsDirective: undefined,
      referencedFiles: [],
      typeReferenceDirectives: [],
      libReferenceDirectives: [],
      amdDependencies: [],
      commentDirectives: undefined,
      nodeCount: 1244,
      identifierCount: 404,
      identifiers: [Map],
      parseDiagnostics: []
    },
    kind: 269,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    modifiers: undefined,
    importClause: NodeObject {
      pos: 561,
      end: 589,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 270,
      isTypeOnly: false,
      name: undefined,
      namedBindings: [NodeObject]
    },
    moduleSpecifier: [Circular *2],
    assertClause: undefined,
    illegalDecorators: undefined
  },
  kind: 10,
  text: '../../../src/documents',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 631,
  end: 645,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 620,
    end: 6543,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 620,
      end: 6544,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [SourceFileObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 620,
      end: 630,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'describe'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 631,
      end: 6542,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'Client Tests',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 166
node: 79
node: 180
node: 79
node: 238
node: 241
node: 210
node: 208
node: 108
node: 79
node: 223
node: 208
node: 208
node: 79
node: 79
node: 79
node: 56
node: 8
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 736,
  end: 769,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 723,
    end: 1462,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 723,
      end: 1463,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 723,
      end: 735,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'describe'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 736,
      end: 1461,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'Validate client request timeout',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 238
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 792,
  end: 834,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 784,
    end: 1456,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 784,
      end: 1457,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 784,
      end: 791,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 792,
      end: 1455,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'timeout occurs within expected timeframe',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 132
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 207
node: 300
node: 79
node: 299
node: 79
node: 79
node: 299
node: 79
node: 207
node: 299
node: 79
node: 8
node: 299
node: 79
node: 95
node: 255
node: 238
node: 241
node: 220
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1236,
  end: 1253,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1219,
    end: 1262,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 1205,
      end: 1262,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 2097536,
      parent: [NodeObject],
      kind: 220,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 1219,
      end: 1235,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'getTestDatabase'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [IdentifierObject],
      pos: 1236,
      end: 1261,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'request timeout',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 79
node: 241
node: 210
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1284,
  end: 1331,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1263,
    end: 1332,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 1263,
      end: 1333,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 1263,
      end: 1283,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      pos: 1284,
      end: 1331,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'Must throw when trying to connect to database',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 295
node: 257
node: 79
node: 131
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1391,
  end: 1406,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1360,
    end: 1440,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 1360,
      end: 1441,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 1360,
      end: 1381,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [Circular *2],
      [TokenObject],
      pos: 1382,
      end: 1439,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'TimeoutError',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 10
<ref *2> TokenObject {
  pos: 1407,
  end: 1439,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1360,
    end: 1440,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 1360,
      end: 1441,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 1360,
      end: 1381,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [TokenObject],
      [Circular *2],
      pos: 1382,
      end: 1439,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'client should throw exception',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1476,
  end: 1489,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1463,
    end: 2996,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 1463,
      end: 2997,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 1463,
      end: 1475,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'describe'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 1476,
      end: 2995,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'Constructor',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 238
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1512,
  end: 1532,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1504,
    end: 1836,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1056,
    parent: NodeObject {
      pos: 1504,
      end: 1837,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1056,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 1504,
      end: 1511,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 1512,
      end: 1835,
      hasTrailingComma: false,
      transformFlags: 1056
    ]
  },
  kind: 10,
  text: 'Accepts node Agent',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 207
node: 299
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1605,
  end: 1629,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1587,
    end: 1629,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 1586,
      end: 1739,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 32,
      parent: [NodeObject],
      kind: 207,
      properties: [Array],
      multiLine: true
    },
    kind: 299,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    name: IdentifierObject {
      pos: 1587,
      end: 1604,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'endpoint'
    },
    initializer: [Circular *2],
    illegalDecorators: undefined,
    modifiers: undefined,
    questionToken: undefined,
    exclamationToken: undefined
  },
  kind: 10,
  text: 'https://faaaaaake.com',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 299
node: 79
node: 211
node: 79
node: 299
node: 79
node: 207
node: 299
node: 79
node: 95
node: 241
node: 210
node: 208
node: 79
node: 79
node: 223
node: 79
node: 37
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1779,
  end: 1827,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1741,
    end: 1828,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 1741,
      end: 1829,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 1741,
      end: 1757,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [Circular *2],
      pos: 1758,
      end: 1827,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: "client shouldn't be undefined if it succeeded",
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 1845,
  end: 1874,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1837,
    end: 2103,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1056,
    parent: NodeObject {
      pos: 1837,
      end: 2104,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1056,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 1837,
      end: 1844,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 1845,
      end: 2102,
      hasTrailingComma: false,
      transformFlags: 1056
    ]
  },
  kind: 10,
  text: 'Accepts a connection string',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 225
node: 15
node: 236
node: 79
node: 16
node: 236
node: 79
node: 17
node: 241
node: 210
node: 208
node: 79
node: 79
node: 223
node: 79
node: 37
node: 79
node: 10
<ref *2> TokenObject {
  pos: 2022,
  end: 2070,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 1984,
    end: 2071,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 1984,
      end: 2072,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 1984,
      end: 2000,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [Circular *2],
      pos: 2001,
      end: 2070,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: "client shouldn't be undefined if it succeeded",
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 208
node: 79
node: 79
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 2112,
  end: 2147,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2104,
    end: 2240,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1056,
    parent: NodeObject {
      pos: 2104,
      end: 2241,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1056,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 2104,
      end: 2111,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 2112,
      end: 2239,
      hasTrailingComma: false,
      transformFlags: 1056
    ]
  },
  kind: 10,
  text: 'throws on a bad connection string',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 216
node: 38
node: 211
node: 79
node: 14
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 2249,
  end: 2275,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2241,
    end: 2376,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1056,
    parent: NodeObject {
      pos: 2241,
      end: 2377,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1056,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 2241,
      end: 2248,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 2249,
      end: 2375,
      hasTrailingComma: false,
      transformFlags: 1056
    ]
  },
  kind: 10,
  text: 'throws on a bad endpoint',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 216
node: 38
node: 211
node: 79
node: 207
node: 299
node: 79
node: 10
<ref *2> TokenObject {
  pos: 2345,
  end: 2364,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2335,
    end: 2364,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 2334,
      end: 2366,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 207,
      properties: [Array],
      multiLine: false
    },
    kind: 299,
    symbol: undefined,
    localSymbol: undefined,
    locals: undefined,
    nextContainer: undefined,
    name: IdentifierObject {
      pos: 2335,
      end: 2344,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'endpoint'
    },
    initializer: [Circular *2],
    illegalDecorators: undefined,
    modifiers: undefined,
    questionToken: undefined,
    exclamationToken: undefined
  },
  kind: 10,
  text: 'asda=asda;asada;',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 2385,
  end: 2438,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2377,
    end: 2990,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 2377,
      end: 2991,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 2377,
      end: 2384,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 2385,
      end: 2989,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'fails to read databases with bad AAD authentication',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 132
node: 238
node: 255
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 10
<ref *2> TokenObject {
  pos: 2531,
  end: 2558,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2499,
    end: 2648,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 32,
    parent: NodeObject {
      pos: 2485,
      end: 2648,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 32,
      parent: [NodeObject],
      kind: 257,
      symbol: undefined,
      localSymbol: undefined,
      locals: undefined,
      nextContainer: undefined,
      name: [IdentifierObject],
      initializer: [Circular *1],
      type: undefined,
      exclamationToken: undefined
    },
    kind: 211,
    expression: IdentifierObject {
      pos: 2503,
      end: 2530,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'UsernamePasswordCredential'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [TokenObject],
      [TokenObject],
      [TokenObject],
      pos: 2531,
      end: 2638,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'fake-tenant-id',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 10
<ref *2> TokenObject {
  pos: 2559,
  end: 2586,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2499,
    end: 2648,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 32,
    parent: NodeObject {
      pos: 2485,
      end: 2648,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 32,
      parent: [NodeObject],
      kind: 257,
      symbol: undefined,
      localSymbol: undefined,
      locals: undefined,
      nextContainer: undefined,
      name: [IdentifierObject],
      initializer: [Circular *1],
      type: undefined,
      exclamationToken: undefined
    },
    kind: 211,
    expression: IdentifierObject {
      pos: 2503,
      end: 2530,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'UsernamePasswordCredential'
    },
    typeArguments: undefined,
    arguments: [
      [TokenObject],
      [Circular *2],
      [TokenObject],
      [TokenObject],
      pos: 2531,
      end: 2638,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'fake-client-id',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 10
<ref *2> TokenObject {
  pos: 2587,
  end: 2612,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2499,
    end: 2648,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 32,
    parent: NodeObject {
      pos: 2485,
      end: 2648,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 32,
      parent: [NodeObject],
      kind: 257,
      symbol: undefined,
      localSymbol: undefined,
      locals: undefined,
      nextContainer: undefined,
      name: [IdentifierObject],
      initializer: [Circular *1],
      type: undefined,
      exclamationToken: undefined
    },
    kind: 211,
    expression: IdentifierObject {
      pos: 2503,
      end: 2530,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'UsernamePasswordCredential'
    },
    typeArguments: undefined,
    arguments: [
      [TokenObject],
      [TokenObject],
      [Circular *2],
      [TokenObject],
      pos: 2531,
      end: 2638,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'fakeUsername',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 10
<ref *2> TokenObject {
  pos: 2613,
  end: 2638,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2499,
    end: 2648,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 32,
    parent: NodeObject {
      pos: 2485,
      end: 2648,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 32,
      parent: [NodeObject],
      kind: 257,
      symbol: undefined,
      localSymbol: undefined,
      locals: undefined,
      nextContainer: undefined,
      name: [IdentifierObject],
      initializer: [Circular *1],
      type: undefined,
      exclamationToken: undefined
    },
    kind: 211,
    expression: IdentifierObject {
      pos: 2503,
      end: 2530,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'UsernamePasswordCredential'
    },
    typeArguments: undefined,
    arguments: [
      [TokenObject],
      [TokenObject],
      [TokenObject],
      [Circular *2],
      pos: 2531,
      end: 2638,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'fakePassword',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 207
node: 300
node: 79
node: 299
node: 79
node: 79
node: 299
node: 79
node: 207
node: 299
node: 79
node: 95
node: 241
node: 220
node: 210
node: 208
node: 210
node: 208
node: 208
node: 79
node: 79
node: 79
node: 79
node: 295
node: 257
node: 79
node: 131
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 2944,
  end: 2973,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2915,
    end: 2974,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 2915,
      end: 2975,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 2915,
      end: 2936,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [Circular *2],
      pos: 2937,
      end: 2973,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'CredentialUnavailableError',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 3009,
  end: 3054,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 2997,
    end: 5469,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 2997,
      end: 5470,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 2997,
      end: 3008,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'describe'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 3009,
      end: 5468,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'Validate user passed AbortController.signal',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 238
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 3077,
  end: 3131,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 3069,
    end: 3681,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 3069,
      end: 3682,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 3069,
      end: 3076,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 3077,
      end: 3680,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'should throw exception if aborted during the request',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 132
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 207
node: 300
node: 79
node: 299
node: 79
node: 79
node: 255
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 240
node: 258
node: 257
node: 79
node: 208
node: 79
node: 79
node: 241
node: 210
node: 79
node: 216
node: 38
node: 210
node: 208
node: 79
node: 79
node: 8
node: 241
node: 220
node: 210
node: 208
node: 79
node: 79
node: 207
node: 299
node: 79
node: 79
node: 241
node: 210
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 3461,
  end: 3508,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 3440,
    end: 3509,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 3440,
      end: 3510,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 3440,
      end: 3460,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      pos: 3461,
      end: 3508,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'Must throw when trying to connect to database',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 295
node: 257
node: 79
node: 131
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 79
node: 241
node: 210
node: 208
node: 79
node: 79
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 3594,
  end: 3607,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 3563,
    end: 3641,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 3563,
      end: 3642,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 3563,
      end: 3584,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [Circular *2],
      [TokenObject],
      pos: 3585,
      end: 3640,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'AbortError',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 10
<ref *2> TokenObject {
  pos: 3608,
  end: 3640,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 3563,
    end: 3641,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 3563,
      end: 3642,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 3563,
      end: 3584,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [TokenObject],
      [Circular *2],
      pos: 3585,
      end: 3640,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'client should throw exception',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 208
node: 79
node: 79
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 3690,
  end: 3750,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 3682,
    end: 4253,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 3682,
      end: 4254,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 3682,
      end: 3689,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 3690,
      end: 4252,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'should throw exception if passed an already aborted signal',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 132
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 207
node: 300
node: 79
node: 299
node: 79
node: 79
node: 255
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 240
node: 258
node: 257
node: 79
node: 208
node: 79
node: 79
node: 241
node: 210
node: 208
node: 79
node: 79
node: 241
node: 220
node: 210
node: 208
node: 79
node: 79
node: 207
node: 299
node: 79
node: 79
node: 241
node: 210
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4059,
  end: 4106,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4038,
    end: 4107,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4038,
      end: 4108,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 4038,
      end: 4058,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      pos: 4059,
      end: 4106,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'Must throw when trying to connect to database',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 295
node: 257
node: 79
node: 131
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4166,
  end: 4179,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4135,
    end: 4213,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4135,
      end: 4214,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 4135,
      end: 4156,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [Circular *2],
      [TokenObject],
      pos: 4157,
      end: 4212,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'AbortError',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 10
<ref *2> TokenObject {
  pos: 4180,
  end: 4212,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4135,
    end: 4213,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4135,
      end: 4214,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 4135,
      end: 4156,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [TokenObject],
      [Circular *2],
      pos: 4157,
      end: 4212,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'client should throw exception',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 208
node: 79
node: 79
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4262,
  end: 4284,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4254,
    end: 4946,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 4254,
      end: 4947,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 4254,
      end: 4261,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 4262,
      end: 4945,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'should abort a query',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 132
node: 238
node: 240
node: 258
node: 257
node: 79
node: 220
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4353,
  end: 4366,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4335,
    end: 4367,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4329,
      end: 4367,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 2097536,
      parent: [NodeObject],
      kind: 220,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 4335,
      end: 4352,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'getTestContainer'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      pos: 4353,
      end: 4366,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'abort query',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 220
node: 210
node: 79
node: 79
node: 210
node: 79
node: 8
node: 255
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 240
node: 258
node: 257
node: 79
node: 208
node: 79
node: 79
node: 241
node: 210
node: 79
node: 216
node: 38
node: 210
node: 208
node: 79
node: 79
node: 8
node: 241
node: 220
node: 210
node: 208
node: 210
node: 208
node: 208
node: 79
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4707,
  end: 4724,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4673,
    end: 4767,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4673,
      end: 4787,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 208,
      expression: [Circular *1],
      name: [IdentifierObject]
    },
    kind: 210,
    expression: NodeObject {
      pos: 4673,
      end: 4706,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [NodeObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 4707,
      end: 4766,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'SELECT * from c',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 207
node: 299
node: 79
node: 79
node: 299
node: 79
node: 8
node: 79
node: 241
node: 210
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4811,
  end: 4823,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4790,
    end: 4824,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4790,
      end: 4825,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 4790,
      end: 4810,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      pos: 4811,
      end: 4823,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'Must throw',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 295
node: 257
node: 79
node: 131
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 208
node: 79
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4883,
  end: 4896,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4852,
    end: 4930,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4852,
      end: 4931,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 4852,
      end: 4873,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [Circular *2],
      [TokenObject],
      pos: 4874,
      end: 4929,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'AbortError',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 10
<ref *2> TokenObject {
  pos: 4897,
  end: 4929,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4852,
    end: 4930,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 0,
    parent: NodeObject {
      pos: 4852,
      end: 4931,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: NodeObject {
      pos: 4852,
      end: 4873,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 208,
      expression: [IdentifierObject],
      name: [IdentifierObject]
    },
    typeArguments: undefined,
    arguments: [
      [NodeObject],
      [TokenObject],
      [Circular *2],
      pos: 4874,
      end: 4929,
      hasTrailingComma: false,
      transformFlags: 0
    ]
  },
  kind: 10,
  text: 'client should throw exception',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 4955,
  end: 5005,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 4947,
    end: 5463,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1441,
    parent: NodeObject {
      pos: 4947,
      end: 5464,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1441,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 4947,
      end: 4954,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 4955,
      end: 5462,
      hasTrailingComma: false,
      transformFlags: 1441
    ]
  },
  kind: 10,
  text: 'should not abort if abort signal is never called',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 132
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 207
node: 300
node: 79
node: 299
node: 79
node: 79
node: 255
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 240
node: 258
node: 257
node: 79
node: 208
node: 79
node: 79
node: 241
node: 220
node: 210
node: 208
node: 79
node: 79
node: 207
node: 299
node: 79
node: 79
node: 295
node: 257
node: 79
node: 131
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 79
node: 241
node: 210
node: 208
node: 79
node: 79
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 5482,
  end: 5504,
  flags: 0,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 5470,
    end: 6539,
    flags: 0,
    modifierFlagsCache: 0,
    transformFlags: 1440,
    parent: NodeObject {
      pos: 5470,
      end: 6540,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 1440,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 5470,
      end: 5481,
      flags: 0,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'describe'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 5482,
      end: 6538,
      hasTrailingComma: false,
      transformFlags: 1440
    ]
  },
  kind: 10,
  text: 'Background refresher',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 132
node: 238
node: 241
node: 210
node: 79
node: 10
<ref *2> TokenObject {
  pos: 5596,
  end: 5624,
  flags: 32768,
  modifierFlagsCache: 0,
  transformFlags: 0,
  parent: <ref *1> NodeObject {
    pos: 5525,
    end: 6533,
    flags: 32768,
    modifierFlagsCache: 0,
    transformFlags: 1184,
    parent: NodeObject {
      pos: 5525,
      end: 6534,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 1184,
      parent: [NodeObject],
      kind: 241,
      expression: [Circular *1]
    },
    kind: 210,
    expression: IdentifierObject {
      pos: 5525,
      end: 5595,
      flags: 32768,
      modifierFlagsCache: 0,
      transformFlags: 0,
      parent: [Circular *1],
      kind: 79,
      originalKeywordKind: undefined,
      escapedText: 'it'
    },
    typeArguments: undefined,
    arguments: [
      [Circular *2],
      [NodeObject],
      pos: 5596,
      end: 6532,
      hasTrailingComma: false,
      transformFlags: 1184
    ]
  },
  kind: 10,
  text: 'should fetch new endpoints',
  singleQuote: undefined,
  hasExtendedUnicodeEscape: false
}
node: 215
node: 166
node: 79
node: 238
node: 240
node: 258
node: 257
node: 79
node: 211
node: 79
node: 207
node: 300
node: 79
node: 299
node: 79
node: 79
node: 299
node: 79
node: 207
node: 301
node: 79
node: 299
node: 79
node: 8
node: 299
node: 79
node: 110
node: 241
node: 210
node: 208
node: 210
node: 208
node: 210
node: 208
node: 79
node: 79
node: 79
node: 216
node: 166
node: 79
node: 38
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 208
node: 79
node: 79
node: 8
node: 241
node: 210
node: 79
node: 216
node: 38
node: 238
node: 241
node: 210
node: 208
node: 210
node: 208
node: 210
node: 208
node: 79
node: 79
node: 79
node: 216
node: 166
node: 79
node: 38
node: 238
node: 241
node: 210
node: 208
node: 79
node: 79
node: 79
node: 79
node: 241
node: 210
node: 79
node: 250
node: 79
node: 208
node: 79
node: 79
node: 8
node: 250
node: 79
node: 208
node: 79
node: 79
node: 1
