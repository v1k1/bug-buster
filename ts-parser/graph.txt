graph LR;
  v0[root] --> v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v2[import assert from "assert";]
  v2[import assert from "assert";] --> v3[assert]
  v3[assert] --> v4[assert]
  v2[import assert from "assert";] --> v5["assert"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v6[import { Suite } from "mocha";]
  v6[import { Suite } from "mocha";] --> v7[{ Suite }]
  v7[{ Suite }] --> v8[{ Suite }]
  v8[{ Suite }] --> v9[Suite]
  v9[Suite] --> v10[Suite]
  v6[import { Suite } from "mocha";] --> v11["mocha"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v12[import { Agent } from "http";]
  v12[import { Agent } from "http";] --> v13[{ Agent }]
  v13[{ Agent }] --> v14[{ Agent }]
  v14[{ Agent }] --> v15[Agent]
  v15[Agent] --> v16[Agent]
  v12[import { Agent } from "http";] --> v17["http"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v18[import { CosmosClient } from "../../../src";]
  v18[import { CosmosClient } from "../../../src";] --> v19[{ CosmosClient }]
  v19[{ CosmosClient }] --> v20[{ CosmosClient }]
  v20[{ CosmosClient }] --> v21[CosmosClient]
  v21[CosmosClient] --> v22[CosmosClient]
  v18[import { CosmosClient } from "../../../src";] --> v23["../../../src"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v24[import { endpoint } from "../common/_testConfig";]
  v24[import { endpoint } from "../common/_testConfig";] --> v25[{ endpoint }]
  v25[{ endpoint }] --> v26[{ endpoint }]
  v26[{ endpoint }] --> v27[endpoint]
  v27[endpoint] --> v28[endpoint]
  v24[import { endpoint } from "../common/_testConfig";] --> v29["../common/_testConfig"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v30[import { masterKey } from "../common/_fakeTestSecrets";]
  v30[import { masterKey } from "../common/_fakeTestSecrets";] --> v31[{ masterKey }]
  v31[{ masterKey }] --> v32[{ masterKey }]
  v32[{ masterKey }] --> v33[masterKey]
  v33[masterKey] --> v34[masterKey]
  v30[import { masterKey } from "../common/_fakeTestSecrets";] --> v35["../common/_fakeTestSecrets"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v36[import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";]
  v36[import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";] --> v37[{
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
}]
  v37[{
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
}] --> v38[{
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
}]
  v38[{
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
}] --> v39[getTestDatabase]
  v39[getTestDatabase] --> v40[getTestDatabase]
  v38[{
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
}] --> v41[getTestContainer]
  v41[getTestContainer] --> v42[getTestContainer]
  v38[{
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
}] --> v43[generateDocuments]
  v43[generateDocuments] --> v44[generateDocuments]
  v38[{
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
}] --> v45[bulkInsertItems]
  v45[bulkInsertItems] --> v46[bulkInsertItems]
  v36[import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";] --> v47["../common/TestHelpers"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v48[import { AbortController } from "node-abort-controller";]
  v48[import { AbortController } from "node-abort-controller";] --> v49[{ AbortController }]
  v49[{ AbortController }] --> v50[{ AbortController }]
  v50[{ AbortController }] --> v51[AbortController]
  v51[AbortController] --> v52[AbortController]
  v48[import { AbortController } from "node-abort-controller";] --> v53["node-abort-controller"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v54[import { UsernamePasswordCredential } from "@azure/identity";]
  v54[import { UsernamePasswordCredential } from "@azure/identity";] --> v55[{ UsernamePasswordCredential }]
  v55[{ UsernamePasswordCredential }] --> v56[{ UsernamePasswordCredential }]
  v56[{ UsernamePasswordCredential }] --> v57[UsernamePasswordCredential]
  v57[UsernamePasswordCredential] --> v58[UsernamePasswordCredential]
  v54[import { UsernamePasswordCredential } from "@azure/identity";] --> v59["@azure/identity"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v60[import { defaultConnectionPolicy } from "../../../src/documents";]
  v60[import { defaultConnectionPolicy } from "../../../src/documents";] --> v61[{ defaultConnectionPolicy }]
  v61[{ defaultConnectionPolicy }] --> v62[{ defaultConnectionPolicy }]
  v62[{ defaultConnectionPolicy }] --> v63[defaultConnectionPolicy]
  v63[defaultConnectionPolicy] --> v64[defaultConnectionPolicy]
  v60[import { defaultConnectionPolicy } from "../../../src/documents";] --> v65["../../../src/documents"]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v66[describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});]
  v66[describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});] --> v67[describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
})]
  v67[describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
})] --> v68[describe]
  v67[describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
})] --> v69["Client Tests"]
  v67[describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
})] --> v70[function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}]
  v70[function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}] --> v71[this: Suite]
  v71[this: Suite] --> v72[this]
  v71[this: Suite] --> v73[Suite]
  v73[Suite] --> v74[Suite]
  v70[function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}] --> v75[{
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}]
  v75[{
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}] --> v76[this.timeout(process.env.MOCHA_TIMEOUT || 20000);]
  v76[this.timeout(process.env.MOCHA_TIMEOUT || 20000);] --> v77[this.timeout(process.env.MOCHA_TIMEOUT || 20000)]
  v77[this.timeout(process.env.MOCHA_TIMEOUT || 20000)] --> v78[this.timeout]
  v78[this.timeout] --> v79[this]
  v78[this.timeout] --> v80[timeout]
  v77[this.timeout(process.env.MOCHA_TIMEOUT || 20000)] --> v81[process.env.MOCHA_TIMEOUT || 20000]
  v81[process.env.MOCHA_TIMEOUT || 20000] --> v82[process.env.MOCHA_TIMEOUT]
  v82[process.env.MOCHA_TIMEOUT] --> v83[process.env]
  v83[process.env] --> v84[process]
  v83[process.env] --> v85[env]
  v82[process.env.MOCHA_TIMEOUT] --> v86[MOCHA_TIMEOUT]
  v81[process.env.MOCHA_TIMEOUT || 20000] --> v87[||]
  v81[process.env.MOCHA_TIMEOUT || 20000] --> v88[20000]
  v75[{
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}] --> v89[describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });]
  v89[describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });] --> v90[describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  })]
  v90[describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  })] --> v91[describe]
  v90[describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  })] --> v92["Validate client request timeout"]
  v90[describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  })] --> v93[function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  }]
  v93[function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  }] --> v94[{
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  }]
  v94[{
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  }] --> v95[it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });]
  v95[it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });] --> v96[it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    })]
  v96[it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    })] --> v97[it]
  v96[it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    })] --> v98["timeout occurs within expected timeframe"]
  v96[it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    })] --> v99[async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    }]
  v99[async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    }] --> v100[async]
  v99[async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    }] --> v101[{
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    }]
  v101[{
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    }] --> v102[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });]
  v102[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });] --> v103[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })]
  v103[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })] --> v104[client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })]
  v104[client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })] --> v105[client]
  v104[client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })] --> v106[new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })]
  v106[new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })] --> v107[CosmosClient]
  v106[new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      })] --> v108[{
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      }]
  v108[{
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      }] --> v109[endpoint]
  v109[endpoint] --> v110[endpoint]
  v108[{
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      }] --> v111[key: masterKey]
  v111[key: masterKey] --> v112[key]
  v111[key: masterKey] --> v113[masterKey]
  v108[{
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      }] --> v114[connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false }]
  v114[connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false }] --> v115[connectionPolicy]
  v114[connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false }] --> v116[{ requestTimeout: 1, enableBackgroundEndpointRefreshing: false }]
  v116[{ requestTimeout: 1, enableBackgroundEndpointRefreshing: false }] --> v117[requestTimeout: 1]
  v117[requestTimeout: 1] --> v118[requestTimeout]
  v117[requestTimeout: 1] --> v119[1]
  v116[{ requestTimeout: 1, enableBackgroundEndpointRefreshing: false }] --> v120[enableBackgroundEndpointRefreshing: false]
  v120[enableBackgroundEndpointRefreshing: false] --> v121[enableBackgroundEndpointRefreshing]
  v120[enableBackgroundEndpointRefreshing: false] --> v122[false]
  v101[{
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    }] --> v123[try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }]
  v123[try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }] --> v124[{
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      }]
  v124[{
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      }] --> v125[await getTestDatabase("request timeout", client);]
  v125[await getTestDatabase("request timeout", client);] --> v126[await getTestDatabase("request timeout", client)]
  v126[await getTestDatabase("request timeout", client)] --> v127[getTestDatabase("request timeout", client)]
  v127[getTestDatabase("request timeout", client)] --> v128[getTestDatabase]
  v127[getTestDatabase("request timeout", client)] --> v129["request timeout"]
  v127[getTestDatabase("request timeout", client)] --> v130[client]
  v124[{
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      }] --> v131[assert.fail("Must throw when trying to connect to database");]
  v131[assert.fail("Must throw when trying to connect to database");] --> v132[assert.fail("Must throw when trying to connect to database")]
  v132[assert.fail("Must throw when trying to connect to database")] --> v133[assert.fail]
  v133[assert.fail] --> v134[assert]
  v133[assert.fail] --> v135[fail]
  v132[assert.fail("Must throw when trying to connect to database")] --> v136["Must throw when trying to connect to database"]
  v123[try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }] --> v137[catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }]
  v137[catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }] --> v138[err: any]
  v138[err: any] --> v139[err]
  v138[err: any] --> v140[any]
  v137[catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }] --> v141[{
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }]
  v141[{
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }] --> v142[assert.equal(err.name, "TimeoutError", "client should throw exception");]
  v142[assert.equal(err.name, "TimeoutError", "client should throw exception");] --> v143[assert.equal(err.name, "TimeoutError", "client should throw exception")]
  v143[assert.equal(err.name, "TimeoutError", "client should throw exception")] --> v144[assert.equal]
  v144[assert.equal] --> v145[assert]
  v144[assert.equal] --> v146[equal]
  v143[assert.equal(err.name, "TimeoutError", "client should throw exception")] --> v147[err.name]
  v147[err.name] --> v148[err]
  v147[err.name] --> v149[name]
  v143[assert.equal(err.name, "TimeoutError", "client should throw exception")] --> v150["TimeoutError"]
  v143[assert.equal(err.name, "TimeoutError", "client should throw exception")] --> v151["client should throw exception"]
  v75[{
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}] --> v152[describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });]
  v152[describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });] --> v153[describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  })]
  v153[describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  })] --> v154[describe]
  v153[describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  })] --> v155["Constructor"]
  v153[describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  })] --> v156[function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }]
  v156[function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }] --> v157[{
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }]
  v157[{
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }] --> v158[it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });]
  v158[it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });] --> v159[it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    })]
  v159[it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    })] --> v160[it]
  v159[it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    })] --> v161["Accepts node Agent"]
  v159[it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    })] --> v162[function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    }]
  v162[function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    }] --> v163[{
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    }]
  v163[{
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    }] --> v164[const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });]
  v164[const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });] --> v165[const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })]
  v165[const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })] --> v166[client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })]
  v166[client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })] --> v167[client]
  v166[client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })] --> v168[new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })]
  v168[new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })] --> v169[CosmosClient]
  v168[new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      })] --> v170[{
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      }]
  v170[{
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      }] --> v171[endpoint: "https://faaaaaake.com"]
  v171[endpoint: "https://faaaaaake.com"] --> v172[endpoint]
  v171[endpoint: "https://faaaaaake.com"] --> v173["https://faaaaaake.com"]
  v170[{
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      }] --> v174[agent: new Agent()]
  v174[agent: new Agent()] --> v175[agent]
  v174[agent: new Agent()] --> v176[new Agent()]
  v176[new Agent()] --> v177[Agent]
  v170[{
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      }] --> v178[connectionPolicy: { enableBackgroundEndpointRefreshing: false }]
  v178[connectionPolicy: { enableBackgroundEndpointRefreshing: false }] --> v179[connectionPolicy]
  v178[connectionPolicy: { enableBackgroundEndpointRefreshing: false }] --> v180[{ enableBackgroundEndpointRefreshing: false }]
  v180[{ enableBackgroundEndpointRefreshing: false }] --> v181[enableBackgroundEndpointRefreshing: false]
  v181[enableBackgroundEndpointRefreshing: false] --> v182[enableBackgroundEndpointRefreshing]
  v181[enableBackgroundEndpointRefreshing: false] --> v183[false]
  v163[{
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    }] --> v184[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");]
  v184[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");] --> v185[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")]
  v185[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")] --> v186[assert.ok]
  v186[assert.ok] --> v187[assert]
  v186[assert.ok] --> v188[ok]
  v185[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")] --> v189[client !== undefined]
  v189[client !== undefined] --> v190[client]
  v189[client !== undefined] --> v191[!==]
  v189[client !== undefined] --> v192[undefined]
  v185[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")] --> v193["client shouldn't be undefined if it succeeded"]
  v157[{
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }] --> v194[it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });]
  v194[it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });] --> v195[it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    })]
  v195[it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    })] --> v196[it]
  v195[it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    })] --> v197["Accepts a connection string"]
  v195[it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    })] --> v198[function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    }]
  v198[function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    }] --> v199[{
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    }]
  v199[{
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    }] --> v200[const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);]
  v200[const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);] --> v201[const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)]
  v201[const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)] --> v202[client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)]
  v202[client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)] --> v203[client]
  v202[client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)] --> v204[new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)]
  v204[new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)] --> v205[CosmosClient]
  v204[new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`)] --> v206[`AccountEndpoint=${endpoint};AccountKey=${masterKey};`]
  v206[`AccountEndpoint=${endpoint};AccountKey=${masterKey};`] --> v207[`AccountEndpoint=${]
  v206[`AccountEndpoint=${endpoint};AccountKey=${masterKey};`] --> v208[endpoint};AccountKey=${]
  v208[endpoint};AccountKey=${] --> v209[endpoint]
  v208[endpoint};AccountKey=${] --> v210[};AccountKey=${]
  v206[`AccountEndpoint=${endpoint};AccountKey=${masterKey};`] --> v211[masterKey};`]
  v211[masterKey};`] --> v212[masterKey]
  v211[masterKey};`] --> v213[};`]
  v199[{
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    }] --> v214[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");]
  v214[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");] --> v215[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")]
  v215[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")] --> v216[assert.ok]
  v216[assert.ok] --> v217[assert]
  v216[assert.ok] --> v218[ok]
  v215[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")] --> v219[client !== undefined]
  v219[client !== undefined] --> v220[client]
  v219[client !== undefined] --> v221[!==]
  v219[client !== undefined] --> v222[undefined]
  v215[assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded")] --> v223["client shouldn't be undefined if it succeeded"]
  v199[{
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    }] --> v224[client.dispose();]
  v224[client.dispose();] --> v225[client.dispose()]
  v225[client.dispose()] --> v226[client.dispose]
  v226[client.dispose] --> v227[client]
  v226[client.dispose] --> v228[dispose]
  v157[{
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }] --> v229[it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });]
  v229[it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });] --> v230[it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    })]
  v230[it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    })] --> v231[it]
  v230[it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    })] --> v232["throws on a bad connection string"]
  v230[it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    })] --> v233[function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    }]
  v233[function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    }] --> v234[{
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    }]
  v234[{
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    }] --> v235[assert.throws(() => new CosmosClient(`bad;Connection=string;`));]
  v235[assert.throws(() => new CosmosClient(`bad;Connection=string;`));] --> v236[assert.throws(() => new CosmosClient(`bad;Connection=string;`))]
  v236[assert.throws(() => new CosmosClient(`bad;Connection=string;`))] --> v237[assert.throws]
  v237[assert.throws] --> v238[assert]
  v237[assert.throws] --> v239[throws]
  v236[assert.throws(() => new CosmosClient(`bad;Connection=string;`))] --> v240[() => new CosmosClient(`bad;Connection=string;`)]
  v240[() => new CosmosClient(`bad;Connection=string;`)] --> v241[=>]
  v240[() => new CosmosClient(`bad;Connection=string;`)] --> v242[new CosmosClient(`bad;Connection=string;`)]
  v242[new CosmosClient(`bad;Connection=string;`)] --> v243[CosmosClient]
  v242[new CosmosClient(`bad;Connection=string;`)] --> v244[`bad;Connection=string;`]
  v157[{
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }] --> v245[it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });]
  v245[it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });] --> v246[it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    })]
  v246[it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    })] --> v247[it]
  v246[it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    })] --> v248["throws on a bad endpoint"]
  v246[it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    })] --> v249[function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    }]
  v249[function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    }] --> v250[{
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    }]
  v250[{
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    }] --> v251[assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));]
  v251[assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));] --> v252[assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }))]
  v252[assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }))] --> v253[assert.throws]
  v253[assert.throws] --> v254[assert]
  v253[assert.throws] --> v255[throws]
  v252[assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }))] --> v256[() => new CosmosClient({ endpoint: "asda=asda;asada;" })]
  v256[() => new CosmosClient({ endpoint: "asda=asda;asada;" })] --> v257[=>]
  v256[() => new CosmosClient({ endpoint: "asda=asda;asada;" })] --> v258[new CosmosClient({ endpoint: "asda=asda;asada;" })]
  v258[new CosmosClient({ endpoint: "asda=asda;asada;" })] --> v259[CosmosClient]
  v258[new CosmosClient({ endpoint: "asda=asda;asada;" })] --> v260[{ endpoint: "asda=asda;asada;" }]
  v260[{ endpoint: "asda=asda;asada;" }] --> v261[endpoint: "asda=asda;asada;"]
  v261[endpoint: "asda=asda;asada;"] --> v262[endpoint]
  v261[endpoint: "asda=asda;asada;"] --> v263["asda=asda;asada;"]
  v157[{
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  }] --> v264[it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });]
  v264[it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });] --> v265[it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    })]
  v265[it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    })] --> v266[it]
  v265[it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    })] --> v267["fails to read databases with bad AAD authentication"]
  v265[it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    })] --> v268[async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    }]
  v268[async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    }] --> v269[async]
  v268[async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    }] --> v270[{
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    }]
  v270[{
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    }] --> v271[try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }]
  v271[try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }] --> v272[{
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      }]
  v272[{
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      }] --> v273[const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );]
  v273[const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );] --> v274[const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )]
  v274[const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v275[credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )]
  v275[credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v276[credentials]
  v275[credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v277[new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )]
  v277[new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v278[UsernamePasswordCredential]
  v277[new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v279["fake-tenant-id"]
  v277[new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v280["fake-client-id"]
  v277[new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v281["fakeUsername"]
  v277[new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        )] --> v282["fakePassword"]
  v272[{
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      }] --> v283[const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });]
  v283[const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });] --> v284[const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })]
  v284[const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })] --> v285[client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })]
  v285[client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })] --> v286[client]
  v285[client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })] --> v287[new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })]
  v287[new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })] --> v288[CosmosClient]
  v287[new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        })] --> v289[{
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        }]
  v289[{
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        }] --> v290[endpoint]
  v290[endpoint] --> v291[endpoint]
  v289[{
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        }] --> v292[aadCredentials: credentials]
  v292[aadCredentials: credentials] --> v293[aadCredentials]
  v292[aadCredentials: credentials] --> v294[credentials]
  v289[{
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        }] --> v295[connectionPolicy: { enableBackgroundEndpointRefreshing: false }]
  v295[connectionPolicy: { enableBackgroundEndpointRefreshing: false }] --> v296[connectionPolicy]
  v295[connectionPolicy: { enableBackgroundEndpointRefreshing: false }] --> v297[{ enableBackgroundEndpointRefreshing: false }]
  v297[{ enableBackgroundEndpointRefreshing: false }] --> v298[enableBackgroundEndpointRefreshing: false]
  v298[enableBackgroundEndpointRefreshing: false] --> v299[enableBackgroundEndpointRefreshing]
  v298[enableBackgroundEndpointRefreshing: false] --> v300[false]
  v272[{
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      }] --> v301[await client.databases.readAll().fetchAll();]
  v301[await client.databases.readAll().fetchAll();] --> v302[await client.databases.readAll().fetchAll()]
  v302[await client.databases.readAll().fetchAll()] --> v303[client.databases.readAll().fetchAll()]
  v303[client.databases.readAll().fetchAll()] --> v304[client.databases.readAll().fetchAll]
  v304[client.databases.readAll().fetchAll] --> v305[client.databases.readAll()]
  v305[client.databases.readAll()] --> v306[client.databases.readAll]
  v306[client.databases.readAll] --> v307[client.databases]
  v307[client.databases] --> v308[client]
  v307[client.databases] --> v309[databases]
  v306[client.databases.readAll] --> v310[readAll]
  v304[client.databases.readAll().fetchAll] --> v311[fetchAll]
  v271[try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }] --> v312[catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }]
  v312[catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }] --> v313[e: any]
  v313[e: any] --> v314[e]
  v313[e: any] --> v315[any]
  v312[catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }] --> v316[{
        assert.equal(e.name, "CredentialUnavailableError");
      }]
  v316[{
        assert.equal(e.name, "CredentialUnavailableError");
      }] --> v317[assert.equal(e.name, "CredentialUnavailableError");]
  v317[assert.equal(e.name, "CredentialUnavailableError");] --> v318[assert.equal(e.name, "CredentialUnavailableError")]
  v318[assert.equal(e.name, "CredentialUnavailableError")] --> v319[assert.equal]
  v319[assert.equal] --> v320[assert]
  v319[assert.equal] --> v321[equal]
  v318[assert.equal(e.name, "CredentialUnavailableError")] --> v322[e.name]
  v322[e.name] --> v323[e]
  v322[e.name] --> v324[name]
  v318[assert.equal(e.name, "CredentialUnavailableError")] --> v325["CredentialUnavailableError"]
  v75[{
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}] --> v326[describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });]
  v326[describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });] --> v327[describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  })]
  v327[describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  })] --> v328[describe]
  v327[describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  })] --> v329["Validate user passed AbortController.signal"]
  v327[describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  })] --> v330[function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  }]
  v330[function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  }] --> v331[{
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  }]
  v331[{
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  }] --> v332[it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });]
  v332[it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });] --> v333[it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })]
  v333[it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })] --> v334[it]
  v333[it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })] --> v335["should throw exception if aborted during the request"]
  v333[it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })] --> v336[async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }]
  v336[async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v337[async]
  v336[async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v338[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }]
  v338[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v339[const client = new CosmosClient({ endpoint, key: masterKey });]
  v339[const client = new CosmosClient({ endpoint, key: masterKey });] --> v340[const client = new CosmosClient({ endpoint, key: masterKey })]
  v340[const client = new CosmosClient({ endpoint, key: masterKey })] --> v341[client = new CosmosClient({ endpoint, key: masterKey })]
  v341[client = new CosmosClient({ endpoint, key: masterKey })] --> v342[client]
  v341[client = new CosmosClient({ endpoint, key: masterKey })] --> v343[new CosmosClient({ endpoint, key: masterKey })]
  v343[new CosmosClient({ endpoint, key: masterKey })] --> v344[CosmosClient]
  v343[new CosmosClient({ endpoint, key: masterKey })] --> v345[{ endpoint, key: masterKey }]
  v345[{ endpoint, key: masterKey }] --> v346[endpoint]
  v346[endpoint] --> v347[endpoint]
  v345[{ endpoint, key: masterKey }] --> v348[key: masterKey]
  v348[key: masterKey] --> v349[key]
  v348[key: masterKey] --> v350[masterKey]
  v338[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v351[try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v351[try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v352[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }]
  v352[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v353[const controller = new AbortController();]
  v353[const controller = new AbortController();] --> v354[const controller = new AbortController()]
  v354[const controller = new AbortController()] --> v355[controller = new AbortController()]
  v355[controller = new AbortController()] --> v356[controller]
  v355[controller = new AbortController()] --> v357[new AbortController()]
  v357[new AbortController()] --> v358[AbortController]
  v352[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v359[const signal = controller.signal;]
  v359[const signal = controller.signal;] --> v360[const signal = controller.signal]
  v360[const signal = controller.signal] --> v361[signal = controller.signal]
  v361[signal = controller.signal] --> v362[signal]
  v361[signal = controller.signal] --> v363[controller.signal]
  v363[controller.signal] --> v364[controller]
  v363[controller.signal] --> v365[signal]
  v352[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v366[setTimeout(() => controller.abort(), 1);]
  v366[setTimeout(() => controller.abort(), 1);] --> v367[setTimeout(() => controller.abort(), 1)]
  v367[setTimeout(() => controller.abort(), 1)] --> v368[setTimeout]
  v367[setTimeout(() => controller.abort(), 1)] --> v369[() => controller.abort()]
  v369[() => controller.abort()] --> v370[=>]
  v369[() => controller.abort()] --> v371[controller.abort()]
  v371[controller.abort()] --> v372[controller.abort]
  v372[controller.abort] --> v373[controller]
  v372[controller.abort] --> v374[abort]
  v367[setTimeout(() => controller.abort(), 1)] --> v375[1]
  v352[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v376[await client.getDatabaseAccount({ abortSignal: signal });]
  v376[await client.getDatabaseAccount({ abortSignal: signal });] --> v377[await client.getDatabaseAccount({ abortSignal: signal })]
  v377[await client.getDatabaseAccount({ abortSignal: signal })] --> v378[client.getDatabaseAccount({ abortSignal: signal })]
  v378[client.getDatabaseAccount({ abortSignal: signal })] --> v379[client.getDatabaseAccount]
  v379[client.getDatabaseAccount] --> v380[client]
  v379[client.getDatabaseAccount] --> v381[getDatabaseAccount]
  v378[client.getDatabaseAccount({ abortSignal: signal })] --> v382[{ abortSignal: signal }]
  v382[{ abortSignal: signal }] --> v383[abortSignal: signal]
  v383[abortSignal: signal] --> v384[abortSignal]
  v383[abortSignal: signal] --> v385[signal]
  v352[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v386[assert.fail("Must throw when trying to connect to database");]
  v386[assert.fail("Must throw when trying to connect to database");] --> v387[assert.fail("Must throw when trying to connect to database")]
  v387[assert.fail("Must throw when trying to connect to database")] --> v388[assert.fail]
  v388[assert.fail] --> v389[assert]
  v388[assert.fail] --> v390[fail]
  v387[assert.fail("Must throw when trying to connect to database")] --> v391["Must throw when trying to connect to database"]
  v351[try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v392[catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v392[catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v393[err: any]
  v393[err: any] --> v394[err]
  v393[err: any] --> v395[any]
  v392[catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v396[{
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v396[{
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v397[console.log(err);]
  v397[console.log(err);] --> v398[console.log(err)]
  v398[console.log(err)] --> v399[console.log]
  v399[console.log] --> v400[console]
  v399[console.log] --> v401[log]
  v398[console.log(err)] --> v402[err]
  v396[{
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v403[assert.equal(err.name, "AbortError", "client should throw exception");]
  v403[assert.equal(err.name, "AbortError", "client should throw exception");] --> v404[assert.equal(err.name, "AbortError", "client should throw exception")]
  v404[assert.equal(err.name, "AbortError", "client should throw exception")] --> v405[assert.equal]
  v405[assert.equal] --> v406[assert]
  v405[assert.equal] --> v407[equal]
  v404[assert.equal(err.name, "AbortError", "client should throw exception")] --> v408[err.name]
  v408[err.name] --> v409[err]
  v408[err.name] --> v410[name]
  v404[assert.equal(err.name, "AbortError", "client should throw exception")] --> v411["AbortError"]
  v404[assert.equal(err.name, "AbortError", "client should throw exception")] --> v412["client should throw exception"]
  v338[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v413[client.dispose();]
  v413[client.dispose();] --> v414[client.dispose()]
  v414[client.dispose()] --> v415[client.dispose]
  v415[client.dispose] --> v416[client]
  v415[client.dispose] --> v417[dispose]
  v331[{
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  }] --> v418[it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });]
  v418[it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });] --> v419[it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })]
  v419[it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })] --> v420[it]
  v419[it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })] --> v421["should throw exception if passed an already aborted signal"]
  v419[it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    })] --> v422[async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }]
  v422[async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v423[async]
  v422[async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v424[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }]
  v424[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v425[const client = new CosmosClient({ endpoint, key: masterKey });]
  v425[const client = new CosmosClient({ endpoint, key: masterKey });] --> v426[const client = new CosmosClient({ endpoint, key: masterKey })]
  v426[const client = new CosmosClient({ endpoint, key: masterKey })] --> v427[client = new CosmosClient({ endpoint, key: masterKey })]
  v427[client = new CosmosClient({ endpoint, key: masterKey })] --> v428[client]
  v427[client = new CosmosClient({ endpoint, key: masterKey })] --> v429[new CosmosClient({ endpoint, key: masterKey })]
  v429[new CosmosClient({ endpoint, key: masterKey })] --> v430[CosmosClient]
  v429[new CosmosClient({ endpoint, key: masterKey })] --> v431[{ endpoint, key: masterKey }]
  v431[{ endpoint, key: masterKey }] --> v432[endpoint]
  v432[endpoint] --> v433[endpoint]
  v431[{ endpoint, key: masterKey }] --> v434[key: masterKey]
  v434[key: masterKey] --> v435[key]
  v434[key: masterKey] --> v436[masterKey]
  v424[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v437[try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v437[try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v438[{
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }]
  v438[{
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v439[const controller = new AbortController();]
  v439[const controller = new AbortController();] --> v440[const controller = new AbortController()]
  v440[const controller = new AbortController()] --> v441[controller = new AbortController()]
  v441[controller = new AbortController()] --> v442[controller]
  v441[controller = new AbortController()] --> v443[new AbortController()]
  v443[new AbortController()] --> v444[AbortController]
  v438[{
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v445[const signal = controller.signal;]
  v445[const signal = controller.signal;] --> v446[const signal = controller.signal]
  v446[const signal = controller.signal] --> v447[signal = controller.signal]
  v447[signal = controller.signal] --> v448[signal]
  v447[signal = controller.signal] --> v449[controller.signal]
  v449[controller.signal] --> v450[controller]
  v449[controller.signal] --> v451[signal]
  v438[{
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v452[controller.abort();]
  v452[controller.abort();] --> v453[controller.abort()]
  v453[controller.abort()] --> v454[controller.abort]
  v454[controller.abort] --> v455[controller]
  v454[controller.abort] --> v456[abort]
  v438[{
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v457[await client.getDatabaseAccount({ abortSignal: signal });]
  v457[await client.getDatabaseAccount({ abortSignal: signal });] --> v458[await client.getDatabaseAccount({ abortSignal: signal })]
  v458[await client.getDatabaseAccount({ abortSignal: signal })] --> v459[client.getDatabaseAccount({ abortSignal: signal })]
  v459[client.getDatabaseAccount({ abortSignal: signal })] --> v460[client.getDatabaseAccount]
  v460[client.getDatabaseAccount] --> v461[client]
  v460[client.getDatabaseAccount] --> v462[getDatabaseAccount]
  v459[client.getDatabaseAccount({ abortSignal: signal })] --> v463[{ abortSignal: signal }]
  v463[{ abortSignal: signal }] --> v464[abortSignal: signal]
  v464[abortSignal: signal] --> v465[abortSignal]
  v464[abortSignal: signal] --> v466[signal]
  v438[{
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      }] --> v467[assert.fail("Must throw when trying to connect to database");]
  v467[assert.fail("Must throw when trying to connect to database");] --> v468[assert.fail("Must throw when trying to connect to database")]
  v468[assert.fail("Must throw when trying to connect to database")] --> v469[assert.fail]
  v469[assert.fail] --> v470[assert]
  v469[assert.fail] --> v471[fail]
  v468[assert.fail("Must throw when trying to connect to database")] --> v472["Must throw when trying to connect to database"]
  v437[try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v473[catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v473[catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v474[err: any]
  v474[err: any] --> v475[err]
  v474[err: any] --> v476[any]
  v473[catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v477[{
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v477[{
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v478[assert.equal(err.name, "AbortError", "client should throw exception");]
  v478[assert.equal(err.name, "AbortError", "client should throw exception");] --> v479[assert.equal(err.name, "AbortError", "client should throw exception")]
  v479[assert.equal(err.name, "AbortError", "client should throw exception")] --> v480[assert.equal]
  v480[assert.equal] --> v481[assert]
  v480[assert.equal] --> v482[equal]
  v479[assert.equal(err.name, "AbortError", "client should throw exception")] --> v483[err.name]
  v483[err.name] --> v484[err]
  v483[err.name] --> v485[name]
  v479[assert.equal(err.name, "AbortError", "client should throw exception")] --> v486["AbortError"]
  v479[assert.equal(err.name, "AbortError", "client should throw exception")] --> v487["client should throw exception"]
  v424[{
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    }] --> v488[client.dispose();]
  v488[client.dispose();] --> v489[client.dispose()]
  v489[client.dispose()] --> v490[client.dispose]
  v490[client.dispose] --> v491[client]
  v490[client.dispose] --> v492[dispose]
  v331[{
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  }] --> v493[it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });]
  v493[it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });] --> v494[it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    })]
  v494[it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    })] --> v495[it]
  v494[it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    })] --> v496["should abort a query"]
  v494[it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    })] --> v497[async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    }]
  v497[async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    }] --> v498[async]
  v497[async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    }] --> v499[{
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    }]
  v499[{
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    }] --> v500[const container = await getTestContainer("abort query");]
  v500[const container = await getTestContainer("abort query");] --> v501[const container = await getTestContainer("abort query")]
  v501[const container = await getTestContainer("abort query")] --> v502[container = await getTestContainer("abort query")]
  v502[container = await getTestContainer("abort query")] --> v503[container]
  v502[container = await getTestContainer("abort query")] --> v504[await getTestContainer("abort query")]
  v504[await getTestContainer("abort query")] --> v505[getTestContainer("abort query")]
  v505[getTestContainer("abort query")] --> v506[getTestContainer]
  v505[getTestContainer("abort query")] --> v507["abort query"]
  v499[{
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    }] --> v508[await bulkInsertItems(container, generateDocuments(20));]
  v508[await bulkInsertItems(container, generateDocuments(20));] --> v509[await bulkInsertItems(container, generateDocuments(20))]
  v509[await bulkInsertItems(container, generateDocuments(20))] --> v510[bulkInsertItems(container, generateDocuments(20))]
  v510[bulkInsertItems(container, generateDocuments(20))] --> v511[bulkInsertItems]
  v510[bulkInsertItems(container, generateDocuments(20))] --> v512[container]
  v510[bulkInsertItems(container, generateDocuments(20))] --> v513[generateDocuments(20)]
  v513[generateDocuments(20)] --> v514[generateDocuments]
  v513[generateDocuments(20)] --> v515[20]
  v499[{
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    }] --> v516[try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v516[try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v517[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      }]
  v517[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      }] --> v518[const controller = new AbortController();]
  v518[const controller = new AbortController();] --> v519[const controller = new AbortController()]
  v519[const controller = new AbortController()] --> v520[controller = new AbortController()]
  v520[controller = new AbortController()] --> v521[controller]
  v520[controller = new AbortController()] --> v522[new AbortController()]
  v522[new AbortController()] --> v523[AbortController]
  v517[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      }] --> v524[const signal = controller.signal;]
  v524[const signal = controller.signal;] --> v525[const signal = controller.signal]
  v525[const signal = controller.signal] --> v526[signal = controller.signal]
  v526[signal = controller.signal] --> v527[signal]
  v526[signal = controller.signal] --> v528[controller.signal]
  v528[controller.signal] --> v529[controller]
  v528[controller.signal] --> v530[signal]
  v517[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      }] --> v531[setTimeout(() => controller.abort(), 50);]
  v531[setTimeout(() => controller.abort(), 50);] --> v532[setTimeout(() => controller.abort(), 50)]
  v532[setTimeout(() => controller.abort(), 50)] --> v533[setTimeout]
  v532[setTimeout(() => controller.abort(), 50)] --> v534[() => controller.abort()]
  v534[() => controller.abort()] --> v535[=>]
  v534[() => controller.abort()] --> v536[controller.abort()]
  v536[controller.abort()] --> v537[controller.abort]
  v537[controller.abort] --> v538[controller]
  v537[controller.abort] --> v539[abort]
  v532[setTimeout(() => controller.abort(), 50)] --> v540[50]
  v517[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      }] --> v541[await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();]
  v541[await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();] --> v542[await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll()]
  v542[await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll()] --> v543[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll()]
  v543[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll()] --> v544[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll]
  v544[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll] --> v545[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })]
  v545[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })] --> v546[container.items
          .query]
  v546[container.items
          .query] --> v547[container.items]
  v547[container.items] --> v548[container]
  v547[container.items] --> v549[items]
  v546[container.items
          .query] --> v550[query]
  v545[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })] --> v551["SELECT * from c"]
  v545[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })] --> v552[{ abortSignal: signal, maxItemCount: 1 }]
  v552[{ abortSignal: signal, maxItemCount: 1 }] --> v553[abortSignal: signal]
  v553[abortSignal: signal] --> v554[abortSignal]
  v553[abortSignal: signal] --> v555[signal]
  v552[{ abortSignal: signal, maxItemCount: 1 }] --> v556[maxItemCount: 1]
  v556[maxItemCount: 1] --> v557[maxItemCount]
  v556[maxItemCount: 1] --> v558[1]
  v544[container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll] --> v559[fetchAll]
  v517[{
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      }] --> v560[assert.fail("Must throw");]
  v560[assert.fail("Must throw");] --> v561[assert.fail("Must throw")]
  v561[assert.fail("Must throw")] --> v562[assert.fail]
  v562[assert.fail] --> v563[assert]
  v562[assert.fail] --> v564[fail]
  v561[assert.fail("Must throw")] --> v565["Must throw"]
  v516[try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v566[catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v566[catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v567[err: any]
  v567[err: any] --> v568[err]
  v567[err: any] --> v569[any]
  v566[catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v570[{
        assert.equal(err.name, "AbortError", "client should throw exception");
      }]
  v570[{
        assert.equal(err.name, "AbortError", "client should throw exception");
      }] --> v571[assert.equal(err.name, "AbortError", "client should throw exception");]
  v571[assert.equal(err.name, "AbortError", "client should throw exception");] --> v572[assert.equal(err.name, "AbortError", "client should throw exception")]
  v572[assert.equal(err.name, "AbortError", "client should throw exception")] --> v573[assert.equal]
  v573[assert.equal] --> v574[assert]
  v573[assert.equal] --> v575[equal]
  v572[assert.equal(err.name, "AbortError", "client should throw exception")] --> v576[err.name]
  v576[err.name] --> v577[err]
  v576[err.name] --> v578[name]
  v572[assert.equal(err.name, "AbortError", "client should throw exception")] --> v579["AbortError"]
  v572[assert.equal(err.name, "AbortError", "client should throw exception")] --> v580["client should throw exception"]
  v331[{
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  }] --> v581[it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });]
  v581[it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });] --> v582[it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    })]
  v582[it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    })] --> v583[it]
  v582[it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    })] --> v584["should not abort if abort signal is never called"]
  v582[it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    })] --> v585[async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    }]
  v585[async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    }] --> v586[async]
  v585[async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    }] --> v587[{
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    }]
  v587[{
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    }] --> v588[const client = new CosmosClient({ endpoint, key: masterKey });]
  v588[const client = new CosmosClient({ endpoint, key: masterKey });] --> v589[const client = new CosmosClient({ endpoint, key: masterKey })]
  v589[const client = new CosmosClient({ endpoint, key: masterKey })] --> v590[client = new CosmosClient({ endpoint, key: masterKey })]
  v590[client = new CosmosClient({ endpoint, key: masterKey })] --> v591[client]
  v590[client = new CosmosClient({ endpoint, key: masterKey })] --> v592[new CosmosClient({ endpoint, key: masterKey })]
  v592[new CosmosClient({ endpoint, key: masterKey })] --> v593[CosmosClient]
  v592[new CosmosClient({ endpoint, key: masterKey })] --> v594[{ endpoint, key: masterKey }]
  v594[{ endpoint, key: masterKey }] --> v595[endpoint]
  v595[endpoint] --> v596[endpoint]
  v594[{ endpoint, key: masterKey }] --> v597[key: masterKey]
  v597[key: masterKey] --> v598[key]
  v597[key: masterKey] --> v599[masterKey]
  v587[{
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    }] --> v600[try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }]
  v600[try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }] --> v601[{
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      }]
  v601[{
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      }] --> v602[const controller = new AbortController();]
  v602[const controller = new AbortController();] --> v603[const controller = new AbortController()]
  v603[const controller = new AbortController()] --> v604[controller = new AbortController()]
  v604[controller = new AbortController()] --> v605[controller]
  v604[controller = new AbortController()] --> v606[new AbortController()]
  v606[new AbortController()] --> v607[AbortController]
  v601[{
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      }] --> v608[const signal = controller.signal;]
  v608[const signal = controller.signal;] --> v609[const signal = controller.signal]
  v609[const signal = controller.signal] --> v610[signal = controller.signal]
  v610[signal = controller.signal] --> v611[signal]
  v610[signal = controller.signal] --> v612[controller.signal]
  v612[controller.signal] --> v613[controller]
  v612[controller.signal] --> v614[signal]
  v601[{
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      }] --> v615[await client.getDatabaseAccount({ abortSignal: signal });]
  v615[await client.getDatabaseAccount({ abortSignal: signal });] --> v616[await client.getDatabaseAccount({ abortSignal: signal })]
  v616[await client.getDatabaseAccount({ abortSignal: signal })] --> v617[client.getDatabaseAccount({ abortSignal: signal })]
  v617[client.getDatabaseAccount({ abortSignal: signal })] --> v618[client.getDatabaseAccount]
  v618[client.getDatabaseAccount] --> v619[client]
  v618[client.getDatabaseAccount] --> v620[getDatabaseAccount]
  v617[client.getDatabaseAccount({ abortSignal: signal })] --> v621[{ abortSignal: signal }]
  v621[{ abortSignal: signal }] --> v622[abortSignal: signal]
  v622[abortSignal: signal] --> v623[abortSignal]
  v622[abortSignal: signal] --> v624[signal]
  v600[try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }] --> v625[catch (err: any) {
        assert.fail(err);
      }]
  v625[catch (err: any) {
        assert.fail(err);
      }] --> v626[err: any]
  v626[err: any] --> v627[err]
  v626[err: any] --> v628[any]
  v625[catch (err: any) {
        assert.fail(err);
      }] --> v629[{
        assert.fail(err);
      }]
  v629[{
        assert.fail(err);
      }] --> v630[assert.fail(err);]
  v630[assert.fail(err);] --> v631[assert.fail(err)]
  v631[assert.fail(err)] --> v632[assert.fail]
  v632[assert.fail] --> v633[assert]
  v632[assert.fail] --> v634[fail]
  v631[assert.fail(err)] --> v635[err]
  v587[{
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    }] --> v636[client.dispose();]
  v636[client.dispose();] --> v637[client.dispose()]
  v637[client.dispose()] --> v638[client.dispose]
  v638[client.dispose] --> v639[client]
  v638[client.dispose] --> v640[dispose]
  v75[{
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
}] --> v641[describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });]
  v641[describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });] --> v642[describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  })]
  v642[describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  })] --> v643[describe]
  v642[describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  })] --> v644["Background refresher"]
  v642[describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  })] --> v645[async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  }]
  v645[async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  }] --> v646[async]
  v645[async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  }] --> v647[{
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  }]
  v647[{
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  }] --> v648[it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });]
  v648[it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });] --> v649[it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    })]
  v649[it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    })] --> v650[it]
  v649[it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    })] --> v651["should fetch new endpoints"]
  v649[it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    })] --> v652[function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    }]
  v652[function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    }] --> v653[done]
  v653[done] --> v654[done]
  v652[function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    }] --> v655[{
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    }]
  v655[{
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    }] --> v656[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });]
  v656[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });] --> v657[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })]
  v657[const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })] --> v658[client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })]
  v658[client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })] --> v659[client]
  v658[client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })] --> v660[new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })]
  v660[new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })] --> v661[CosmosClient]
  v660[new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      })] --> v662[{
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      }]
  v662[{
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      }] --> v663[endpoint]
  v663[endpoint] --> v664[endpoint]
  v662[{
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      }] --> v665[key: masterKey]
  v665[key: masterKey] --> v666[key]
  v665[key: masterKey] --> v667[masterKey]
  v662[{
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      }] --> v668[connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        }]
  v668[connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        }] --> v669[connectionPolicy]
  v668[connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        }] --> v670[{
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        }]
  v670[{
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        }] --> v671[...defaultConnectionPolicy]
  v671[...defaultConnectionPolicy] --> v672[defaultConnectionPolicy]
  v670[{
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        }] --> v673[endpointRefreshRateInMs: 700]
  v673[endpointRefreshRateInMs: 700] --> v674[endpointRefreshRateInMs]
  v673[endpointRefreshRateInMs: 700] --> v675[700]
  v670[{
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        }] --> v676[enableBackgroundEndpointRefreshing: true]
  v676[enableBackgroundEndpointRefreshing: true] --> v677[enableBackgroundEndpointRefreshing]
  v676[enableBackgroundEndpointRefreshing: true] --> v678[true]
  v655[{
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    }] --> v679[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);]
  v679[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);] --> v680[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn)]
  v680[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn)] --> v681[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch]
  v681[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch] --> v682[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })]
  v682[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })] --> v683[client
        .getReadEndpoints()
        .then]
  v683[client
        .getReadEndpoints()
        .then] --> v684[client
        .getReadEndpoints()]
  v684[client
        .getReadEndpoints()] --> v685[client
        .getReadEndpoints]
  v685[client
        .getReadEndpoints] --> v686[client]
  v685[client
        .getReadEndpoints] --> v687[getReadEndpoints]
  v683[client
        .getReadEndpoints()
        .then] --> v688[then]
  v682[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })] --> v689[(firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }]
  v689[(firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }] --> v690[firstEndpoints]
  v690[firstEndpoints] --> v691[firstEndpoints]
  v689[(firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }] --> v692[=>]
  v689[(firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }] --> v693[{
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }]
  v693[{
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }] --> v694[assert.equal(firstEndpoints.length, 0);]
  v694[assert.equal(firstEndpoints.length, 0);] --> v695[assert.equal(firstEndpoints.length, 0)]
  v695[assert.equal(firstEndpoints.length, 0)] --> v696[assert.equal]
  v696[assert.equal] --> v697[assert]
  v696[assert.equal] --> v698[equal]
  v695[assert.equal(firstEndpoints.length, 0)] --> v699[firstEndpoints.length]
  v699[firstEndpoints.length] --> v700[firstEndpoints]
  v699[firstEndpoints.length] --> v701[length]
  v695[assert.equal(firstEndpoints.length, 0)] --> v702[0]
  v693[{
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }] --> v703[setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);]
  v703[setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);] --> v704[setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200)]
  v704[setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200)] --> v705[setTimeout]
  v704[setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200)] --> v706[() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }]
  v706[() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }] --> v707[=>]
  v706[() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }] --> v708[{
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }]
  v708[{
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }] --> v709[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);]
  v709[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);] --> v710[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn)]
  v710[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn)] --> v711[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch]
  v711[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch] --> v712[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })]
  v712[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })] --> v713[client
              .getReadEndpoints()
              .then]
  v713[client
              .getReadEndpoints()
              .then] --> v714[client
              .getReadEndpoints()]
  v714[client
              .getReadEndpoints()] --> v715[client
              .getReadEndpoints]
  v715[client
              .getReadEndpoints] --> v716[client]
  v715[client
              .getReadEndpoints] --> v717[getReadEndpoints]
  v713[client
              .getReadEndpoints()
              .then] --> v718[then]
  v712[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })] --> v719[(endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }]
  v719[(endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }] --> v720[endpoints]
  v720[endpoints] --> v721[endpoints]
  v719[(endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }] --> v722[=>]
  v719[(endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }] --> v723[{
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }]
  v723[{
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }] --> v724[assert.notEqual(firstEndpoints, endpoints);]
  v724[assert.notEqual(firstEndpoints, endpoints);] --> v725[assert.notEqual(firstEndpoints, endpoints)]
  v725[assert.notEqual(firstEndpoints, endpoints)] --> v726[assert.notEqual]
  v726[assert.notEqual] --> v727[assert]
  v726[assert.notEqual] --> v728[notEqual]
  v725[assert.notEqual(firstEndpoints, endpoints)] --> v729[firstEndpoints]
  v725[assert.notEqual(firstEndpoints, endpoints)] --> v730[endpoints]
  v723[{
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }] --> v731[done();]
  v731[done();] --> v732[done()]
  v732[done()] --> v733[done]
  v723[{
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              }] --> v734[return;]
  v711[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch] --> v735[catch]
  v710[client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn)] --> v736[console.warn]
  v736[console.warn] --> v737[console]
  v736[console.warn] --> v738[warn]
  v704[setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200)] --> v739[1200]
  v693[{
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        }] --> v740[return;]
  v681[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch] --> v741[catch]
  v680[client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn)] --> v742[console.warn]
  v742[console.warn] --> v743[console]
  v742[console.warn] --> v744[warn]
  v1[import assert from "assert";
import { Suite } from "mocha";
import { Agent } from "http";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import {
  getTestDatabase,
  getTestContainer,
  generateDocuments,
  bulkInsertItems,
} from "../common/TestHelpers";
import { AbortController } from "node-abort-controller";
import { UsernamePasswordCredential } from "@azure/identity";
import { defaultConnectionPolicy } from "../../../src/documents";

describe("Client Tests", function (this: Suite) {
  this.timeout(process.env.MOCHA_TIMEOUT || 20000);

  describe("Validate client request timeout", function () {
    it("timeout occurs within expected timeframe", async function () {
      // making timeout 1 ms to make sure it will throw
      // (create database request takes 10ms-15ms to finish on emulator)
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: { requestTimeout: 1, enableBackgroundEndpointRefreshing: false },
      });
      // create database
      try {
        await getTestDatabase("request timeout", client);
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "TimeoutError", "client should throw exception");
      }
    });
  });

  describe("Constructor", function () {
    it("Accepts node Agent", function () {
      const client = new CosmosClient({
        endpoint: "https://faaaaaake.com",
        agent: new Agent(),
        connectionPolicy: { enableBackgroundEndpointRefreshing: false },
      });
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
    });
    it("Accepts a connection string", function () {
      const client = new CosmosClient(`AccountEndpoint=${endpoint};AccountKey=${masterKey};`);
      assert.ok(client !== undefined, "client shouldn't be undefined if it succeeded");
      client.dispose();
    });
    it("throws on a bad connection string", function () {
      assert.throws(() => new CosmosClient(`bad;Connection=string;`));
    });
    it("throws on a bad endpoint", function () {
      assert.throws(() => new CosmosClient({ endpoint: "asda=asda;asada;" }));
    });
    it("fails to read databases with bad AAD authentication", async function () {
      try {
        const credentials = new UsernamePasswordCredential(
          "fake-tenant-id",
          "fake-client-id",
          "fakeUsername",
          "fakePassword"
        );
        const client = new CosmosClient({
          endpoint,
          aadCredentials: credentials,
          connectionPolicy: { enableBackgroundEndpointRefreshing: false },
        });
        await client.databases.readAll().fetchAll();
      } catch (e: any) {
        assert.equal(e.name, "CredentialUnavailableError");
      }
    });
  });
  describe("Validate user passed AbortController.signal", function () {
    it("should throw exception if aborted during the request", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 1);
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        console.log(err);
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should throw exception if passed an already aborted signal", async function () {
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        controller.abort();
        await client.getDatabaseAccount({ abortSignal: signal });
        assert.fail("Must throw when trying to connect to database");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
      client.dispose();
    });
    it("should abort a query", async function () {
      const container = await getTestContainer("abort query");
      await bulkInsertItems(container, generateDocuments(20));
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() => controller.abort(), 50);
        // Setting maxItemCount = 1 to ensure this query take a long time
        await container.items
          .query("SELECT * from c", { abortSignal: signal, maxItemCount: 1 })
          .fetchAll();
        assert.fail("Must throw");
      } catch (err: any) {
        assert.equal(err.name, "AbortError", "client should throw exception");
      }
    });
    it("should not abort if abort signal is never called", async function () {
      // Testing the happy path to prevent this bug https://github.com/Azure/azure-sdk-for-js/issues/9510
      const client = new CosmosClient({ endpoint, key: masterKey });
      try {
        const controller = new AbortController();
        const signal = controller.signal;
        await client.getDatabaseAccount({ abortSignal: signal });
      } catch (err: any) {
        assert.fail(err);
      }
      client.dispose();
    });
  });
  describe("Background refresher", async function () {
    // not async to leverage done() callback inside setTimeout
    it("should fetch new endpoints", function (done) {
      // set refresh rate to 700ms
      const client = new CosmosClient({
        endpoint,
        key: masterKey,
        connectionPolicy: {
          ...defaultConnectionPolicy,
          endpointRefreshRateInMs: 700,
          enableBackgroundEndpointRefreshing: true,
        },
      });

      // then timeout 1.2s so that we first fetch no endpoints, then after it refreshes we see them
      client
        .getReadEndpoints()
        .then((firstEndpoints) => {
          assert.equal(firstEndpoints.length, 0);
          setTimeout(() => {
            client
              .getReadEndpoints()
              .then((endpoints) => {
                assert.notEqual(firstEndpoints, endpoints);
                done();
                return;
              })
              .catch(console.warn);
          }, 1200);
          return;
        })
        .catch(console.warn);
    });
  });
});
] --> v745[]
